---
title: "Build Real-time Applications"
icon: "bolt"
description: "Access low-latency blockchain data for mobile apps, trading bots, and live dashboards"
---

## Overview

Perfect for mobile developers, DeFi applications, and real-time monitoring systems that need fast access to the latest blockchain data.

## What You'll Learn

- Choose the right API for your latency needs
- Build real-time data feeds
- Optimize for mobile and web apps
- Handle live updates efficiently
- Build trading bots and monitoring systems

## When to Use Analytics API vs Simulation APIs

<Note>
**Analytics API** is optimized for querying historical data and running complex analytics. **Simulation APIs** are designed for real-time, low-latency access to live blockchain data.

- **Use Analytics API when:** You need comprehensive historical analysis, complex queries with joins, or data aggregations
- **Use Simulation APIs when:** You need sub-second latency for live price feeds, real-time transaction monitoring, or instant smart contract state queries

[Learn more about Simulation APIs ‚Üí](https://docs.dune.com/api-reference/sim-api/overview)
</Note>

## Quick Start with Analytics API

### 1. Real-time Price Feed

Build a live price feed for tokens:

<CodeGroup>
```python Python
from dune_client import DuneClient
import time

dune = DuneClient(api_key="YOUR_API_KEY")

def get_latest_prices(tokens):
    """Get latest prices for specified tokens"""
    token_list = "', '".join(tokens)
    
    sql = f"""
    SELECT 
        token_symbol,
        price_usd,
        block_time,
        blockchain
    FROM prices.usd
    WHERE token_symbol IN ('{token_list}')
    AND block_time > now() - interval '5' minute
    ORDER BY block_time DESC
    """
    
    results = dune.execute(sql=sql)
    return {row['token_symbol']: row['price_usd'] for row in results.rows}

# Update prices every minute
while True:
    prices = get_latest_prices(['WETH', 'USDC', 'WBTC'])
    print(f"WETH: ${prices['WETH']:.2f}")
    time.sleep(60)
```

```typescript TypeScript
import { DuneClient } from '@duneanalytics/client';

const dune = new DuneClient('YOUR_API_KEY');

async function getLatestPrices(tokens: string[]) {
  const tokenList = tokens.map(t => `'${t}'`).join(', ');
  
  const sql = `
    SELECT 
      token_symbol,
      price_usd,
      block_time,
      blockchain
    FROM prices.usd
    WHERE token_symbol IN (${tokenList})
    AND block_time > now() - interval '5' minute
    ORDER BY block_time DESC
  `;
  
  const results = await dune.execute({ sql });
  
  return results.rows.reduce((acc, row) => {
    acc[row.token_symbol] = row.price_usd;
    return acc;
  }, {});
}

// Update prices every minute
setInterval(async () => {
  const prices = await getLatestPrices(['WETH', 'USDC', 'WBTC']);
  console.log(`WETH: $${prices.WETH.toFixed(2)}`);
}, 60000);
```
</CodeGroup>

### 2. Live Transaction Monitoring

Monitor transactions in real-time for specific addresses or protocols:

<CodeGroup>
```python Python
from dune_client import DuneClient
import time

dune = DuneClient(api_key="YOUR_API_KEY")

def monitor_transactions(contract_address):
    """Monitor transactions for a specific contract"""
    sql = f"""
    SELECT 
        block_time,
        tx_hash,
        "from" as sender,
        "to" as recipient,
        value / 1e18 as eth_value
    FROM ethereum.transactions
    WHERE "to" = 0x{contract_address}
    AND block_time > now() - interval '5' minute
    ORDER BY block_time DESC
    """
    
    results = dune.execute(sql=sql)
    
    for tx in results.rows:
        print(f"New TX: {tx['tx_hash'][:10]}... - {tx['eth_value']} ETH")
        # Send notification, update dashboard, etc.

# Poll every 30 seconds
while True:
    monitor_transactions("a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48")  # USDC
    time.sleep(30)
```

```typescript TypeScript
import { DuneClient } from '@duneanalytics/client';

const dune = new DuneClient('YOUR_API_KEY');

async function monitorTransactions(contractAddress: string) {
  const sql = `
    SELECT 
      block_time,
      tx_hash,
      "from" as sender,
      "to" as recipient,
      value / 1e18 as eth_value
    FROM ethereum.transactions
    WHERE "to" = 0x${contractAddress}
    AND block_time > now() - interval '5' minute
    ORDER BY block_time DESC
  `;
  
  const results = await dune.execute({ sql });
  
  for (const tx of results.rows) {
    console.log(`New TX: ${tx.tx_hash.slice(0, 10)}... - ${tx.eth_value} ETH`);
    // Send notification, update dashboard, etc.
  }
}

// Poll every 30 seconds
setInterval(async () => {
  await monitorTransactions("a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48");
}, 30000);
```
</CodeGroup>

### 3. Mobile App Integration

Optimize API calls for mobile apps:

```typescript
import { DuneClient } from '@duneanalytics/client';

class DuneMobileClient {
  private dune: DuneClient;
  private cache: Map<string, { data: any; timestamp: number }>;
  private cacheDuration: number = 60000; // 1 minute

  constructor(apiKey: string) {
    this.dune = new DuneClient(apiKey);
    this.cache = new Map();
  }

  async getPortfolioValue(address: string) {
    // Check cache first
    const cached = this.cache.get(`portfolio_${address}`);
    if (cached && Date.now() - cached.timestamp < this.cacheDuration) {
      return cached.data;
    }

    // Fetch fresh data
    const sql = `
      SELECT 
        SUM(amount_usd) as total_value,
        blockchain,
        token_symbol
      FROM tokens.balances
      WHERE wallet_address = '${address}'
      GROUP BY blockchain, token_symbol
    `;

    const results = await this.dune.execute({ sql });
    
    // Cache results
    this.cache.set(`portfolio_${address}`, {
      data: results,
      timestamp: Date.now()
    });

    return results;
  }

  async getRecentActivity(address: string, limit: number = 10) {
    const sql = `
      SELECT 
        block_time,
        tx_hash,
        token_symbol,
        amount,
        usd_value
      FROM tokens.transfers
      WHERE "from" = '${address}' OR "to" = '${address}'
      AND block_time > now() - interval '24' hour
      ORDER BY block_time DESC
      LIMIT ${limit}
    `;

    return await this.dune.execute({ sql });
  }
}

// Usage in React Native
const client = new DuneMobileClient('YOUR_API_KEY');

async function loadWalletData(address: string) {
  const [portfolio, activity] = await Promise.all([
    client.getPortfolioValue(address),
    client.getRecentActivity(address)
  ]);
  
  // Update UI
  updatePortfolio(portfolio);
  updateActivity(activity);
}
```

### 4. Live Dashboard Updates

Build a live dashboard with automatic updates:

```javascript
import { DuneClient } from '@duneanalytics/client';

const dune = new DuneClient('YOUR_API_KEY');

class LiveDashboard {
  constructor() {
    this.updateInterval = 30000; // 30 seconds
    this.metrics = {};
  }

  async updateMetrics() {
    const queries = [
      {
        name: 'totalVolume',
        sql: `SELECT SUM(amount_usd) as volume FROM dex.trades WHERE block_time > now() - interval '24' hour`
      },
      {
        name: 'activeUsers',
        sql: `SELECT COUNT(DISTINCT trader) as users FROM dex.trades WHERE block_time > now() - interval '1' hour`
      },
      {
        name: 'gasPrice',
        sql: `SELECT AVG(gas_price / 1e9) as gwei FROM ethereum.transactions WHERE block_time > now() - interval '10' minute`
      }
    ];

    // Execute all queries in parallel
    const results = await Promise.all(
      queries.map(q => dune.execute({ sql: q.sql }))
    );

    // Update metrics
    queries.forEach((q, i) => {
      this.metrics[q.name] = results[i].rows[0];
    });

    // Update UI
    this.render();
  }

  render() {
    document.getElementById('volume').textContent = 
      `$${this.metrics.totalVolume?.volume.toLocaleString()}`;
    document.getElementById('users').textContent = 
      this.metrics.activeUsers?.users.toLocaleString();
    document.getElementById('gas').textContent = 
      `${this.metrics.gasPrice?.gwei.toFixed(1)} gwei`;
  }

  start() {
    // Initial load
    this.updateMetrics();
    
    // Auto-refresh
    setInterval(() => this.updateMetrics(), this.updateInterval);
  }
}

// Start the dashboard
const dashboard = new LiveDashboard();
dashboard.start();
```

## Building a Trading Bot

Create an automated trading bot that monitors opportunities:

```python
from dune_client import DuneClient
import time
from decimal import Decimal

dune = DuneClient(api_key="YOUR_API_KEY")

class ArbitrageBot:
    def __init__(self):
        self.min_profit_threshold = Decimal('100')  # $100 minimum profit
        
    def find_arbitrage_opportunities(self):
        """Find cross-DEX arbitrage opportunities"""
        sql = """
        WITH dex_prices AS (
          SELECT 
            token_address,
            token_symbol,
            project as dex,
            AVG(price_usd) as price,
            SUM(amount_usd) as liquidity
          FROM dex.trades
          WHERE block_time > now() - interval '5' minute
          AND blockchain = 'ethereum'
          GROUP BY 1, 2, 3
        )
        SELECT 
          a.token_symbol,
          a.dex as dex_buy,
          a.price as price_buy,
          b.dex as dex_sell,
          b.price as price_sell,
          ((b.price - a.price) / a.price * 100) as profit_percent,
          LEAST(a.liquidity, b.liquidity) as available_liquidity
        FROM dex_prices a
        JOIN dex_prices b ON a.token_address = b.token_address
        WHERE a.dex != b.dex
        AND b.price > a.price * 1.01  -- At least 1% profit
        ORDER BY profit_percent DESC
        LIMIT 10
        """
        
        results = dune.execute(sql=sql)
        return results.rows
    
    def evaluate_opportunity(self, opp):
        """Evaluate if opportunity is worth executing"""
        potential_profit = (
            Decimal(str(opp['profit_percent'])) / 100 * 
            Decimal(str(opp['available_liquidity']))
        )
        
        if potential_profit > self.min_profit_threshold:
            print(f"üö® Arbitrage Alert!")
            print(f"Token: {opp['token_symbol']}")
            print(f"Buy on {opp['dex_buy']} at ${opp['price_buy']:.4f}")
            print(f"Sell on {opp['dex_sell']} at ${opp['price_sell']:.4f}")
            print(f"Profit: {opp['profit_percent']:.2f}%")
            print(f"Potential: ${potential_profit:.2f}")
            
            # Execute trade (implement your trading logic here)
            # self.execute_trade(opp)
    
    def run(self):
        """Main bot loop"""
        print("Starting arbitrage bot...")
        
        while True:
            try:
                opportunities = self.find_arbitrage_opportunities()
                
                for opp in opportunities:
                    self.evaluate_opportunity(opp)
                
                time.sleep(30)  # Check every 30 seconds
                
            except Exception as e:
                print(f"Error: {e}")
                time.sleep(60)

# Run the bot
bot = ArbitrageBot()
bot.run()
```

## Optimization Tips

<AccordionGroup>
  <Accordion title="Minimize query execution time">
    - Keep queries focused on recent data (last few minutes/hours)
    - Use indexed columns in WHERE clauses (block_time, blockchain, etc.)
    - Limit result sets to what you actually need
    - Consider materialized views for frequently-accessed data
  </Accordion>

  <Accordion title="Implement smart caching">
    ```python
    from functools import lru_cache
    from datetime import datetime
    
    @lru_cache(maxsize=100)
    def cached_price_query(token, minute):
        # Cache results for each minute
        sql = f"SELECT price_usd FROM prices.usd WHERE token_symbol = '{token}' LIMIT 1"
        return dune.execute(sql=sql)
    
    # Use current minute as cache key
    current_minute = datetime.now().strftime("%Y-%m-%d %H:%M")
    result = cached_price_query("WETH", current_minute)
    ```
  </Accordion>

  <Accordion title="Batch requests when possible">
    ```python
    # Instead of multiple single queries
    # ‚ùå Bad
    eth_price = dune.execute(sql="SELECT price FROM prices WHERE symbol='ETH'")
    btc_price = dune.execute(sql="SELECT price FROM prices WHERE symbol='BTC'")
    
    # ‚úÖ Good - single query
    prices = dune.execute(sql="""
      SELECT symbol, price FROM prices 
      WHERE symbol IN ('ETH', 'BTC')
    """)
    ```
  </Accordion>

  <Accordion title="Use webhooks for event-driven updates">
    Instead of polling, set up webhooks to receive notifications:
    
    ```python
    # Configure webhook for query completion
    dune.create_webhook(
        query_id=query_id,
        webhook_url="https://your-app.com/webhook"
    )
    ```
  </Accordion>
</AccordionGroup>

## When to Use Simulation APIs

For ultra-low latency requirements (sub-second), consider Dune's Simulation APIs:

<CardGroup cols={2}>
  <Card title="Live Price Feeds" icon="chart-candlestick">
    Sub-second price updates for trading applications
    
    [Learn more ‚Üí](https://docs.dune.com/api-reference/sim-api/prices)
  </Card>
  
  <Card title="Smart Contract Simulation" icon="microchip">
    Simulate transactions before execution
    
    [Learn more ‚Üí](https://docs.dune.com/api-reference/sim-api/simulate)
  </Card>
  
  <Card title="Real-time State Queries" icon="database">
    Query current blockchain state instantly
    
    [Learn more ‚Üí](https://docs.dune.com/api-reference/sim-api/state)
  </Card>
  
  <Card title="WebSocket Streams" icon="signal-stream">
    Subscribe to live data streams
    
    [Learn more ‚Üí](https://docs.dune.com/api-reference/sim-api/websockets)
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Webhooks" icon="webhook" href="/api-reference/webhooks/webhook">
    Set up webhooks for event-driven updates
  </Card>
  
  <Card title="Rate Limits" icon="gauge" href="/api-reference/overview/rate-limits">
    Understand rate limits for real-time apps
  </Card>
  
  <Card title="Caching Strategies" icon="box-archive" href="/api-reference/overview/troubleshooting">
    Learn about caching and optimization
  </Card>
  
  <Card title="Simulation APIs" icon="bolt" href="https://docs.dune.com/api-reference/sim-api/overview">
    Explore ultra-low latency options
  </Card>
</CardGroup>

## Example Use Cases

- **Mobile Wallets:** Display real-time portfolio values and transaction history
- **Trading Bots:** Monitor prices and execute automated trades
- **Live Dashboards:** Show real-time protocol metrics and chain activity
- **Alerting Systems:** Notify users of important events (large trades, price movements)
- **DeFi Apps:** Display current pool states, APYs, and market conditions
- **NFT Platforms:** Show live floor prices and recent sales

